from fastapi import FastAPI, File, UploadFile
from fastapi.middleware.cors import CORSMiddleware
from paddleocr import PaddleOCR
import cv2
import numpy as np
import re
from typing import Any, Dict, List, Optional, Tuple

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

print("Loading PaddleOCR...")
ocr = PaddleOCR(use_angle_cls=True, lang="en", show_log=False)
print("PaddleOCR Ready! - Waiting for Bill...")

CURRENCY_PATTERN = re.compile(r"(?:\u20B9|Rs\.?|INR|\$)?\s*(\d{1,3}(?:,\d{3})*|\d+)(?:\.(\d{1,2}))?")
STRUCTURED_ITEM_PATTERN = re.compile(
    r"^(?P<name>[A-Za-z][A-Za-z0-9 &()/+\-]{1,}?)\s+"
    r"(?P<qty>\d{1,2})\s+"
    r"(?P<unit>\d+(?:\.\d{1,2})?)\s+"
    r"(?P<total>\d+(?:\.\d{1,2})?)\s*$"
)
QTY_PATTERN = re.compile(r"(?i)\b(?:qty|quantity)\s*[:=-]?\s*(\d+(?:\.\d+)?)\b")
MULTIPLY_QTY_PATTERN = re.compile(r"(?i)\b(\d+(?:\.\d+)?)\s*[x*]\b")
TRAILING_QTY_X_PATTERN = re.compile(r"(?i)\bx\s*(\d+(?:\.\d+)?)\b")
NON_ITEM_PATTERN = re.compile(
    r"(?i)\b(?:tel|phone|email|@|www|http|invoice|ticket|table|date|time|receipt|"
    r"thank|delivery|address|no[:#]?|pm|am|phnom|cambodia)\b"
)

HARD_SKIP_WORDS = {
    "total",
    "subtotal",
    "tax",
    "vat",
    "gst",
    "cgst",
    "sgst",
    "service charge",
    "change",
    "cash",
    "visa",
    "mastercard",
    "amex",
    "paid",
    "payment",
    "balance",
}

SOFT_REMOVE_WORDS = {
    "date",
    "time",
    "ticket",
    "table",
    "invoice",
    "items",
    "price",
    "tel",
    "phone",
    "email",
    "restaurant",
    "server",
    "bill no",
    "bill#",
    "receipt",
    "amount",
}


def estimate_line_threshold(boxes: List[Any]) -> float:
    heights: List[float] = []
    for box in boxes:
        pts = box[0]
        ys = [p[1] for p in pts]
        heights.append(max(ys) - min(ys))
    if not heights:
        return 10.0
    median_h = float(np.median(heights))
    return max(8.0, min(20.0, median_h * 0.65))


def cluster_ocr_lines(boxes: List[Any]) -> List[List[Tuple[str, float, float, float]]]:
    words: List[Tuple[str, float, float, float]] = []
    for box in boxes:
        text = box[1][0].strip()
        conf = float(box[1][1])
        if not text or conf < 0.35:
            continue
        pts = box[0]
        x = float(sum(p[0] for p in pts) / 4.0)
        y = float(sum(p[1] for p in pts) / 4.0)
        words.append((text, x, y, conf))

    words.sort(key=lambda item: item[2])
    threshold = estimate_line_threshold(boxes)

    lines: List[List[Tuple[str, float, float, float]]] = []
    current: List[Tuple[str, float, float, float]] = []
    current_y: Optional[float] = None

    for word in words:
        _, _, y, _ = word
        if current_y is None or abs(y - current_y) <= threshold:
            current.append(word)
            current_y = y if current_y is None else (current_y * 0.7 + y * 0.3)
        else:
            current.sort(key=lambda item: item[1])
            lines.append(current)
            current = [word]
            current_y = y

    if current:
        current.sort(key=lambda item: item[1])
        lines.append(current)

    return lines


def normalize_line_text(line_text: str) -> str:
    text = re.sub(r"(\d\.\d{2})(?=\d)", r"\1 ", line_text)
    text = re.sub(r"[|]", " ", text)
    text = re.sub(r"\s+", " ", text).strip()
    for word in SOFT_REMOVE_WORDS:
        text = re.sub(rf"(?i)\b{re.escape(word)}\b", " ", text)
    text = re.sub(r"\s+", " ", text).strip()
    return text


def should_skip_line(line_text: str) -> bool:
    lower = line_text.lower()
    if any(word in lower for word in HARD_SKIP_WORDS):
        return True
    if NON_ITEM_PATTERN.search(line_text):
        return True
    if line_text.startswith("#"):
        return True
    return False


def parse_money_values(text: str) -> List[float]:
    values: List[float] = []
    for match in CURRENCY_PATTERN.finditer(text):
        whole = match.group(1).replace(",", "")
        frac = match.group(2) if match.group(2) else ""
        number_str = f"{whole}.{frac}" if frac else whole
        try:
            value = float(number_str)
        except ValueError:
            continue
        if 0 < value < 100000:
            values.append(value)
    return values


def infer_quantity(line_text: str, money_values: List[float]) -> float:
    qty_match = QTY_PATTERN.search(line_text)
    if qty_match:
        return float(qty_match.group(1))

    mul_match = MULTIPLY_QTY_PATTERN.search(line_text)
    if mul_match:
        return float(mul_match.group(1))

    trailing_x_match = TRAILING_QTY_X_PATTERN.search(line_text)
    if trailing_x_match:
        return float(trailing_x_match.group(1))

    standalone_numbers = []
    for m in re.finditer(r"\b\d+(?:\.\d+)?\b", line_text):
        val = float(m.group())
        if any(abs(val - money) < 0.001 for money in money_values):
            continue
        standalone_numbers.append(val)

    for val in standalone_numbers:
        if 0 < val <= 20 and float(val).is_integer():
            return val

    return 1.0


def clean_name(line_text: str) -> str:
    text = re.sub(r"(?i)\b(?:qty|quantity)\s*[:=-]?\s*\d+(?:\.\d+)?\b", " ", line_text)
    text = re.sub(r"(?i)\b\d+(?:\.\d+)?\s*[x*]\b", " ", text)
    text = re.sub(r"(?i)\bx\s*\d+(?:\.\d+)?\b", " ", text)
    text = re.sub(r"(?:\u20B9|Rs\.?|INR|\$)?\s*\d{1,3}(?:,\d{3})*(?:\.\d{1,2})?", " ", text)
    text = re.sub(r"[^A-Za-z0-9 &()/+-]", " ", text)
    text = re.sub(r"\s+", " ", text).strip(" -:")
    return text


def parse_structured_item(line_text: str) -> Optional[Dict[str, Any]]:
    match = STRUCTURED_ITEM_PATTERN.match(line_text)
    if not match:
        return None

    name = clean_name(match.group("name"))
    if len(name) < 2:
        return None

    quantity = int(match.group("qty"))
    unit_price = round(float(match.group("unit")), 2)
    cost = round(float(match.group("total")), 2)
    if quantity <= 0 or cost < 0.5:
        return None

    return {
        "name": name,
        "quantity": quantity,
        "unit_price": unit_price,
        "cost": cost,
    }


def extract_items_from_lines(lines: List[List[Tuple[str, float, float, float]]]) -> List[Dict[str, Any]]:
    items: List[Dict[str, Any]] = []
    seen = set()

    for line in lines:
        raw_line = " ".join(word[0] for word in line)
        if not raw_line:
            continue

        normalized = normalize_line_text(raw_line)
        if not normalized or should_skip_line(normalized):
            continue

        structured_item = parse_structured_item(normalized)
        if structured_item:
            key = (
                structured_item["name"].lower(),
                structured_item["quantity"],
                structured_item["unit_price"],
                structured_item["cost"],
            )
            if key not in seen:
                items.append(structured_item)
                seen.add(key)
            continue

        money_values = parse_money_values(normalized)
        if len(money_values) < 2:
            continue

        cost = round(money_values[-1], 2)
        if cost < 0.5:
            continue

        quantity = infer_quantity(normalized, money_values)
        if quantity <= 0:
            quantity = 1.0

        unit_price = round(money_values[-2], 2)
        if abs((unit_price * quantity) - cost) > max(1.0, 0.08 * cost):
            unit_price = round(cost / quantity, 2)

        name = clean_name(normalized)
        if len(name) < 2:
            continue

        quantity_out: Any = int(quantity) if float(quantity).is_integer() else quantity
        key = (name.lower(), quantity_out, unit_price, cost)
        if key in seen:
            continue

        items.append(
            {
                "name": name,
                "quantity": quantity_out,
                "unit_price": unit_price,
                "cost": cost,
            }
        )
        seen.add(key)

    return items


@app.post("/scan-bill")
async def scan_bill(file: UploadFile = File(...)):
    try:
        image_data = await file.read()
        nparr = np.frombuffer(image_data, np.uint8)
        image = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        if image is None:
            return {"items": [], "error": "Invalid image"}

        result = ocr.ocr(image, cls=True)
        if not result or not result[0]:
            return {"items": [], "debug": "Blank Image"}

        lines = cluster_ocr_lines(result[0])
        items = extract_items_from_lines(lines)
        return {"items": items}
    except Exception as e:
        return {"items": [], "error": str(e)}
